#!/usr/bin/env ruby
require 'rubygems'
require 'daemons'

ENV["RAILS_ENV"] = ARGV[1] || ENV["RAILS_ENV"] || "production"

root = File.join(File.expand_path(File.dirname(__FILE__)), '..')

# monkey patch daemons to give better file names
module Daemons
  class PidFile < Pid
    def filename
      File.join(@dir, "#{@progname}#{@number ? "_#{@number}" : ''}.pid")
    end
  end
end

options = {
  :app_name   => "resque_worker",
  :ARGV       => ARGV,
  :dir_mode   => :normal,
  :dir        => File.join(root, 'log'),
  :log_output => true,
  :multiple   => false,
  :backtrace  => true,
  :monitor    => false
}

Daemons.run_proc(options[:app_name], options) do
  require File.expand_path(File.join(root, %w(config environment)))
  require 'resque'

  worker = nil
  queues = (ENV['QUEUES'] || ENV['QUEUE']).to_s.split(',')

  begin
    worker = Resque::Worker.new(*queues)
    worker.verbose = ENV['LOGGING'] || ENV['VERBOSE']
    worker.very_verbose = ENV['VVERBOSE']
  rescue Resque::NoQueueError
    abort "set QUEUE env var, e.g. $ QUEUE=critical,high rake resque:work"
  end

  puts "*** Starting worker #{worker}"

  worker.work(ENV['INTERVAL'] || 1) # interval, will block
end
